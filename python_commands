#creating a list using for loop and range function
lst = list(x for x in range(10))
#if the format is list-like, even if you have to provide a single value, use [].
#renaming columns
passing it to df.columns = ['renamed_of_new_column1', 'renamed_of_new_column2']
#deleting column
del df['column name']
#reording columns
df_reordered = df_original[['list_of_reordered_columns']]
#printing entire data frame
print(df.to_string())
#slicing, replacing strings in individual series or column from dataframe
country = energy['Country'].str.replace(' \(', '(') ## \ is used as escape character. 
country = energy['Country'].str.split('(').str.get(0)

#slicing using re.split #Used in coursera, course #1, Assignment 4
import re
re.split(' \(+', 'Words (words, words.')[0] #Have to pass each row individually, not on column
###re.split info and illustations:
#format:
re.split(pattern, string[, maxsplit=0])
Explanation:
Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups 
in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, 
and the remainder of the string is returned as the final element of the list.
Illustations:
1. Code for column in data frame #This is twice as fast if tow functions are used per above method. (first replace and then split)
>>> import re
>>> vector = []
>>> for row in df.RegionName:
>>>   row = re.split(' \(+', row)[0]
>>>   vector.append(row)
    
>>> re.split('\W+', 'Words, words, words.')
['Words', 'words', 'words', '']
>>> re.split('(\W+)', 'Words, words, words.')
['Words', ', ', 'words', ', ', 'words', '.', '']
>>> re.split('\W+', 'Words, words, words.', 1)
['Words', 'words, words.']
#setting, replacing index
df.set_index('Index', drop = True, inplace=True)
df1 = df.reset_index(drop = True)

#Using map(), filter(), reduce() in python 3.0
>>>def f(x): return x % 2 != 0 and x % 3 != 0
#filter
>>> list(filter(f, range(2, 25)))
[5, 7, 11, 13, 17, 19, 23]
>>> def cube(x): return x*x*x
#map
>>> list(map(cube, range(1, 11)))
[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]
#reduce
>>> import functools
>>> def add(x,y): return x+y
...
>>> functools.reduce(add, range(1, 11))

#Getting index using Boolean mask of a data frame, follwing commands gives list
index = df[df['% Renewable'] == max].index.tolist()

#Getting index using Boolean mask of a series, follwing commands gives list
series[series == series[2]].index[0]

###Always assign a copy of data frame if you want to process it unless you want to change original. If you assign original to new variable 
and change that variable, the original also gets changed, unless the copy has made while assigning it to new variable. 
new_variable_data_frame = old_variable_data_frame.copy()


###There is a difference between type 'numpy.float64' and just 'float'. It may matter depending on the output requirement. 

#Iterative code to read a line from text file in raw format: (Refer documentation for 'f.readlines(filesize = int--(in bytes, optional)' if following method does not suit the purpose)
>>> f = open('university_towns.txt')
>>> for line in f:
>>>   output = repr(line)  # The repr() of a string adds string quotes and backslashes:
>>>   print(output)

#Getting an index of an item in the dataframe:
index = df.index(item)

#Getting average(mean) of several columns in a data frame:
df['avg'] = df[['Monday', 'Tuesday']].mean(axis=1)

#getting a key of a dictionary
mydict.keys()[mydict.values().index(value)]
mydict.keys()[mydict.values().index(16)]
#getting a value of a dictionary
dict.get(key, default=None)

#Using dictionary to map values of a dataframe column
df['new_column_name'] = df['column_which_needs_to_be_mapped_has_the_entries_similar_to_the_dictionary_keys'].map(dictionary_name)

##Querying data frame, getting a row of a dataframe:
df['Column_name'].iloc[row_number] #for getting a specific item
#entire row of all columns:
df.iloc[['row_number']]

