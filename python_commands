#creating a list using for loop and range function
lst = list(x for x in range(10))
#if the format is list-like, even if you have to provide a single value, use [].
#renaming columns
passing it to df.columns = ['renamed_of_new_column1', 'renamed_of_new_column2']
#deleting column
del df['column name']
#reording columns
df_reordered = df_original[['list_of_reordered_columns']]
#printing entire data frame
print(df.to_string())
#slicing, replacing strings in individual series or column from dataframe
country = energy['Country'].str.replace(' \(', '(') ## \ is used as escape character. 
country = energy['Country'].str.split('(').str.get(0)

#slicing using re.split #Used in coursera, course #1, Assignment 4
import re
re.split(' \(+', 'Words (words, words.')[0] #Have to pass each row individually, not on column
###re.split info and illustations:
#format:
re.split(pattern, string[, maxsplit=0])
Explanation:
Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups 
in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, 
and the remainder of the string is returned as the final element of the list.
Illustations:
1. Code for column in data frame #This is twice as fast if tow functions are used per above method. (first replace and then split)
>>> import re
>>> vector = []
>>> for row in df.RegionName:
>>>   row = re.split(' \(+', row)[0]
>>>   vector.append(row)
    
>>> re.split('\W+', 'Words, words, words.')
['Words', 'words', 'words', '']
>>> re.split('(\W+)', 'Words, words, words.')
['Words', ', ', 'words', ', ', 'words', '.', '']
>>> re.split('\W+', 'Words, words, words.', 1)
['Words', 'words, words.']
#setting, replacing index
df.set_index('Index', drop = True, inplace=True)
df1 = df.reset_index(drop = True)

#Using map(), filter(), reduce() in python 3.0
>>>def f(x): return x % 2 != 0 and x % 3 != 0
#filter
>>> list(filter(f, range(2, 25)))
[5, 7, 11, 13, 17, 19, 23]
>>> def cube(x): return x*x*x
#map
>>> list(map(cube, range(1, 11)))
[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]
#reduce
>>> import functools
>>> def add(x,y): return x+y
...
>>> functools.reduce(add, range(1, 11))

#Getting index using Boolean mask of a data frame, follwing commands gives list
index = df[df['% Renewable'] == max].index.tolist()

#Getting index using Boolean mask of a series, follwing commands gives list
series[series == 'element_of_which_index_is_needed'].index[0]

###Always assign a copy of data frame if you want to process it unless you want to change original. If you assign original to new variable 
and change that variable, the original also gets changed, unless the copy has made while assigning it to new variable. 
new_variable_data_frame = old_variable_data_frame.copy()


###There is a difference between type 'numpy.float64' and just 'float'. It may matter depending on the output requirement. 

#Iterative code to read a line from text file in raw format: (Refer documentation for 'f.readlines(filesize = int--(in bytes, optional)' if following method does not suit the purpose)
>>> f = open('university_towns.txt')
>>> for line in f:
>>>   output = repr(line)  # The repr() of a string adds string quotes and backslashes:
>>>   print(output)

#Getting an index of an item in the dataframe:
index = df.index(item)

#Getting average(mean) of several columns in a data frame:
df['avg'] = df[['Monday', 'Tuesday']].mean(axis=1)

#getting a key of a dictionary
mydict.keys()[mydict.values().index(value)]
mydict.keys()[mydict.values().index(16)]
#getting a value of a dictionary
dict.get(key, default=None)

#Using dictionary to map values of a dataframe column
df['new_column_name'] = df['column_which_needs_to_be_mapped_has_the_entries_similar_to_the_dictionary_keys'].map(dictionary_name)

##Querying data frame, getting a row of a dataframe:
df['Column_name'].iloc[row_number] #for getting a specific item
#entire row of all columns:
df.iloc[['row_number']]
OR TRY THIS - q4_1.T[['row_number']].T
##getting list of all the items in that row:
print(list(q4_1.iloc['row_number']))

#Getting diagonal elements of a numpy array: (Assuming array has shape 3X3 like this:)
>>> x = np.array([[1, 2, 3], [4, 5, 6]]
>>> x.reshape(9)[::4]

### For grouping columns through multi-inidex with each row in index on3 (level 0) shows all of the releted rows in second index (level 1), 
first sort the first index (level 0) alphabetically -- then and then only all level 1 entries related to specific level 0 would be 
in a single row. 
# Function for sorting a list alphabetically:
>>> sorted(list_name/column_name_in_dataframe)


### Sorting a particular column and re-arranging rows in a data frame:
df_sorted = df_copy.sort('column_name_to_sortwise').reset_index(drop = True) #along with resetting index, if required. Dont forget to make 
a copy. Its safer that way!

#Getting index in mulitiindex:
>>> df.index.get_level_values(0)
>>> index.get_level_values('second')

#inserting a thousand separator(comma) (,) in a number 
>>> '{:,}'.format(1234567890)
### For common string operators refer the link: https://docs.python.org/3/library/string.html#format-specification-mini-language

### If data frame has word(label) index then getting an for getting integer index for that label index:
df.index.get_loc('label_index_name')

# Replacing a value in dataframe:
df.replace(to_replace='item_to_replace', value='replacement_value', inplace=True/False)

##Timeit magic function:
>> %%timeit -n 10
